es6:
	1.let
	2.箭头函数
	3.参数增强
	4.模板字符串
	5.解构
	6.OOP
	7.for of
	8.****promise

1.let
	作用：
		1.防止声明提前
		2.新增块级作用域
3.参数简化
	3.spread:散播
		什么：打散数组类型参数为单个元素
		何时：取代 .concat()   .apply();
		如何：fun(...数组)
		es5：fun.apply(obj,数组);
4.模板字符串

5.解构
	1.数组解构：	解构==>数组批量赋值给变量
	2.对象解构：
		var obj = {
			math:89,
			chs:56,
			eng:91
		}
		var {math,chs,eng}=obj;

6.OOP
	面向对象简化
		1.创建一个类型
			用class 结构包裹构造函数和原型对象
			将构造函数名提升为类型名放在class后
			将"function 类型名" 改为 "constructor"
				class  类型名{//构造函数名升级为类名
					constructor(属性参数列表){
						this.属性名= 属性参数;
							... = ...;
					}
					//类型名.prototype={==>这些方法自动放在原型对象中
						方法1(){...},
						方法2(){...}
					//}
				}
		2.继承
			1.让子类型继承父类型
				class Sub extend Father
			2.在子类型构造函数中，借用父类型构造函数
				super==>自动指向父类型构造函数，并且，自动替换其中this为当前对象
				super(属性参数列表)

		3.访问器属性
		4.静态方法
			保存在构造函数上
			何时：只要一个方法，不确定将来执行时的类型，
			如何：static 静态方法(){}==>和constructor平级
			调用：类型名.静态方法();
		5.重写
			子类型重写父类型，要调用父类型是，super.方法();





